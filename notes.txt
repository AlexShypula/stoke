Release Features:

Support for x86_64 instruction set ONLY.
Should have some ideas in place to minimize the potential for bit-rot.

Where can bit-rot happen?

Instruction Set: New instructions are added
Hardware: New/wider registers are added
Cost Model: Instruction latencies change
Validator: Need new circuits to accomadate new instructions

What parts of the code need to be flexible:

Instruction Set: Assembler should be updateable. 
	We've already refactored this out, so all this means is wedding ourselves to 
	a non-changing api. Should spend some time figuring out exactly what this is.
	That's fine, really.
	I should go through a similar refactoring process there and say I'm done with the project.

Hardware: State data structure
	Register count and width should be customizable from command line

Cost Model: Array.
	This is stored in an array, so this isn't too hard.
	We can toggle this from the command line as well.

Validator:
	This is somewhat dependent on rahul, so we'll need to finalize an api for him.

Should these be command line options, or should they be build options?
I think build, since so much of stoke is target-dependent anyway.
You might as well specialize your build to the target that you're working on.

Should we have haskell code in the release?

Haskell just seems like a barrier to entry.
I'm happy to tell people that they need a c++11 compiler and that's it.
It's easy enough to remove it to keep things simple.
This will mean also getting rid of haskell in the assembler.

What is the bare minimum funcitonality that we want to release?
We have some internal command line stuff that's nice, but probably complicates things a bit.

stoke scrape -> Pull a .s file out of a binary (doesn't need to be executable)
             -> But stoke scrape doesn't work on what you produce. There's an ugly asymmetry here.
						 -> But the asymmetry isn't here. It's with search.
						 -> We might want to call this stoke extract.
stoke testcase -> Run a binary and produce a testcase
stoke search -> Synthesis/Optimization ... plus validation
						 -> Right now there's an ugly asymmetry between inputs and outputs here.
						 -> You can't rerun search on the outputs of search. We'll have to fix this.
						 -> We just need to wrap code in an object that reads/prints something like elf.
stoke replace -> Replace a binary? This is too hard for me to know how to do.
							-> We can leave this bit of the process up to the user.


What about all the other fancy stuff that we built?
It's mostly for debugging internally.

stoke cfg -> Debug the control flow graph directory
stoke cost -> Debug the cost function directory
stoke simulate -> Debug the sandbox directory
stoke validate -> Debug the validator

Let's have two command line programs:
	-> stoke (scrape | testcase | search)
	-> stoke_debug (cfg | cost | simulate | validate)

Let's also try to remove the dependence on environment variables.
I know how to do that pretty well.

What about features? Do we want to be able to run stoke on loops?
Really there's no particular difficulty here as far as I'm concerned. 
It's all just up to the validator.

What about examples? Let's try to include as much as we can from all of our papers.
-> Gulwani (ASPLOS)
-> Bansal (ASPLOS)
-> SAXPY (ASPLOS)
-> MontMul (ASPLOS)
-> Trig (PLDI)
-> Log (PLDI)

