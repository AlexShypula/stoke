{"name":"Stoke","tagline":"STOKE: A stochastic optimizer","body":"STOKE\r\n=====\r\n\r\nSTOKE is a stochastic optimizer for the x86-64 instruction set. STOKE uses\r\nrandom search to explore the extremely high-dimensional space of all possible\r\nprogram transformations. Although any one random transformation is unlikely to\r\nproduce a code sequence that is both correct and an improvement over the\r\noriginal, the repeated application of millions of transformations is sufficient\r\nto produce novel and non-obvious code sequences that have been shown to\r\noutperform the code produced by general-purpose and domain-specific compilers,\r\nand in some cases expert hand-written code.\r\n\r\nSTOKE has appeared in a number of publications. For a thorough introduction to\r\nthe design of STOKE, see:\r\n\r\n- [**Stochastic Superoptimization** -- ASPLOS 2013](https://raw.githubusercontent.com/StanfordPL/stoke/develop/docs/papers/asplos13.pdf):\r\n- [**Data-Driven Equivalence Checking** -- OOPSLA 2013](https://raw.githubusercontent.com/StanfordPL/stoke/develop/docs/papers/oopsla13b.pdf):\r\n- [**Stochastic Optimization of Floating-Point Programs with Tunable Precision** -- PLDI 2014](https://raw.githubusercontent.com/StanfordPL/stoke/develop/docs/papers/pldi14a.pdf):\r\n- [**Conditionally Correct Superoptimization** -- OOPSLA 2015](https://raw.githubusercontent.com/StanfordPL/stoke/develop/docs/papers/oopsla15a.pdf):\r\n\r\nTable of Contents\r\n=====\r\n0. [Prerequisites](#prerequisites)\r\n1. [Choosing a STOKE version](#choosing-a-stoke-version)\r\n2. [Building STOKE](#building-stoke)\r\n 1. [Using the formal validator](#using-the-formal-validator)\r\n3. [Using STOKE](#using-stoke)\r\n4. [Additional Features](#additional-features)\r\n5. [Extending STOKE](#extending-stoke)\r\n 1. [Code Organization](#code-organization)\r\n 2. [Gadgets](#gadgets)\r\n 3. [Initial Search State](#initial-search-state)\r\n 4. [Search Transformations](#search-transformations)\r\n 5. [Cost Function](#cost-function)\r\n 6. [Live-out Error](#live-out-error)\r\n 7. [Verification Strategy](#verification-strategy)\r\n 8. [Command Line Args](#command-line-args)\r\n6. [Contact](#contact)\r\n\r\nPrerequisites\r\n=====\r\n\r\nSTOKE will run on modern 64-bit x86 processors.  We officially support Haswell\r\nprocessors with AVX2 extensions.  STOKE should also run on Sandy Bridge\r\nsystems (with AVX, but not AVX2), and Nehalem systems without either extension.\r\n\r\nTo check what level of hardware support you have, run:\r\n\r\n    $ less /proc/cpuinfo\r\n\r\nand check if the following cpu flags are present:\r\n\r\n    flags: ... avx avx2 bmi bmi2 popcnt ...\r\n\r\nIf you don't have 'avx' or 'avx2', you will need to compile for nehalem.  If\r\nyou have 'avx', but not avx2, you will compile for 'sandybridge'.  If you have\r\nboth, you can compile for 'haswell'.  Build instructions are in the next\r\nsection.\r\n\r\nSTOKE is supported on the latest Ubuntu LTS release; in practice, it will also\r\nrun on Ubuntu 13.10+ and on debian testing.  If you're trying to get STOKE to\r\nwork on another linux distribution, having the right version of g++ is key.\r\nSTOKE is supported on 4.9 only.\r\nIt should also work on later versions, but it will not work with g++ 4.8.x (missing regular expression support), and  g++ 4.7.x and older\r\ndefinitely will not work.\r\n\r\nMost of STOKE's software dependencies are available through apt. These can be\r\nsatisfied by typing:\r\n\r\n    $ sudo apt-get install bison ccache cmake doxygen exuberant-ctags flex g++-4.9 g++-multilib gcc-4.9 ghc git libantlr3c-dev libboost-dev libboost-filesystem-dev libboost-thread-dev libcln-dev libghc-regex-compat-dev libghc-regex-tdfa-dev libghc-split-dev libjsoncpp-dev python subversion libiml-dev libgmp-dev\r\n\r\nThe rest of the dependencies will be fetched automatically as part of the build\r\nprocess.\r\n\r\nDownloading STOKE\r\n=====\r\n\r\nThe entire STOKE code base is available on GitHub under the Apache Software\r\nLicense version 2.0 at [github.com/StanfordPL/stoke](https://github.com/StanfordPL/stoke/).\r\n\r\nTo check it out, type:\r\n\r\n    $ git clone https://github.com/StanfordPL/stoke\r\n\r\nThis will check out the default `develop` branch.  Unless you are looking for a specific version or modification of STOKE, this is the branch to use.  It contains all the latest changes and is reasonably stable.  This branch is supposed to always pass all tests.\r\n\r\nBuilding STOKE\r\n=====\r\n\r\nSee the previous sections on how to download STOKE, a list of dependencies, and to check your hardware\r\nsupport level.  The remainder of STOKE's software dependencies are available on\r\nGitHub and will be downloaded automatically the first time that STOKE is built.  When you build STOKE the first time, run\r\n\r\n    $ ./configure.sh\r\n\r\nThis will figure out the correct build parameters (such as the platform).  To build STOKE, run\r\n\r\n    $ make\r\n\r\nTo add STOKE and its related components to your path, type:\r\n\r\n    $ export PATH=$PATH:/<path_to_stoke>/bin\r\n\r\nTo run the tests, choose the appropriate command:\r\n\r\n    $ make test\r\n\r\nThe files generated during the build process can be deleted by typing:\r\n\r\n    $ make clean\r\n\r\nTo delete STOKE's dependencies as well (this is useful if an error occurs during the first build), type:\r\n\r\n    $ make dist_clean\r\n\r\n\r\n\r\nUsing STOKE\r\n=====\r\n\r\nThe following toy example shows a typical workflow for using STOKE. All of the\r\nfollowing code can be found in the `examples/tutorial/` directory.  As this\r\ncode is tested using our continuous integration system, the code there will\r\nalways be up-to-date, but this README can fall behind.\r\n\r\nConsider a\r\nC++ program that repeatedly counts the number of bits (population count) in the\r\n64-bit representation of an integer. (Keeping track of a running sum prevents\r\n`g++` from eliminating the calls to `popcnt()` altogether.)\r\n\r\n```c++\r\n// main.cc\r\n\r\n#include <cstdlib>\r\n#include <stddef.h>\r\n#include <stdint.h>\r\n\r\nusing namespace std;\r\n\r\nsize_t popcnt(uint64_t x) {\r\n  int res = 0;\r\n  for ( ; x > 0; x >>= 1 ) {\r\n    res += x & 0x1ull;\r\n  }\r\n  return res;\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n  const auto itr = atoi(argv[1]);\r\n\r\n  auto ret = 0;\r\n  for ( auto i = 0; i < itr; ++i ) {\r\n    ret += popcnt(i);\r\n  }\r\n\r\n  return ret;\r\n```\r\n\r\nSTOKE is a compiler and programming language agnostic optimization tool. It can\r\nbe applied to any x86-64 ELF binary. Although this example uses the GNU\r\ntoolchain, nothing prevents the use of other tools. To build this code with\r\nfull optimizations, type:\r\n\r\n    $ g++ -std=c++11 -O3 -fno-inline main.cc\r\n    \r\nTo measure runtime, type:\r\n\r\n    $ time ./a.out 100000000\r\n    \r\n    real  0m1.046s\r\n    user  0m1.047s\r\n    sys   0m0.000s\r\n    \r\nA profiler will reveal that the runtime of `./a.out` is dominated by calls to\r\nthe `popcnt()` function. STOKE can be used to improve the implementation of\r\nthis function as follows. The first step is to disassemble the program by\r\ntyping:\r\n\r\n    $ stoke extract -i ./a.out -o bins\r\n    \r\nThis will produce a directory named `bins` that contains the text of every\r\nfunction contained in the binary `./a.out`. \r\n\r\nHelp for stoke or any of its subcommands can be obtained by typing:\r\n\r\n    $ stoke -h\r\n    $ stoke <subcommand> -h\r\n    \r\nSTOKE can accept arguments either through the command line or through a\r\nconfiguration file. The invocation of `stoke extract` shown above is equivalent\r\nto the following:\r\n\r\n    $ stoke extract --config extract.conf\r\n    \r\nWhere `extract.conf` contains:\r\n\r\n```\r\n##### stoke extract config file\r\n\r\n-i ./a.out # Path to the elf binary to disassemble\r\n-o bins # Path to the directory to store disassembled text in\r\n```\r\n\r\nEvery STOKE subcommand can be used to generate example configuration files by\r\ntyping:\r\n\r\n    $ stoke <subcommand> --example_config <path/to/file.conf>\r\n\r\nBecause `main.cc` was compiled using `g++`, the text of the `popcnt()` function\r\nwill appear under the mangled name `_Z6popcntm` in `bins/_Z6popcntm.s`.\r\n\r\n```asm\r\n  .text\r\n  .globl _Z6popcntm\r\n  .type _Z6popcntm, @function\r\n_Z6popcntm:\r\n  xorl   %eax,%eax\r\n  testq  %rdi,%rdi\r\n  je     .L_4005b0\r\n  nop\r\n.L_4005a0:\r\n  movq   %rdi,%rdx\r\n  andl   $0x1,%edx\r\n  addq   %rdx,%rax\r\n  shrq   $0x1,%rdi\r\n  jne    .L_4005a0\r\n  retq\r\n.L_4005b0:\r\n  retq\r\n  nop\r\n  nop\r\n  .size _Z6popcntm, .-_Z6popcntm\r\n```\r\n\r\nThe next step is to generate a set of testcases for guiding STOKE's search\r\nprocedure. These can be obtained by typing:\r\n\r\n    $ stoke testcase --config testcase.conf\r\n    \r\nwhere `testcase.conf` contains:\r\n\r\n```\r\n##### stoke testcase config file\r\n\r\n--bin ./a.out # The name of the binary to use to generate testcases \r\n--args 10000000 # Command line arguments that should be passed to ./a.out\r\n--functions bins # Disassembly directory created by stoke extract\r\n\r\n-o popcnt.tc # Path to file to write testcases to\r\n\r\n--fxn _Z6popcntm # The name of the function to generate testcases for\r\n--max_testcases 1024 # The maximum number of testcases to generate. \r\n```\r\n\r\nThe resulting file will contain 1024 entires, all of the form:\r\n\r\n```\r\nTestcase 0:\r\n\r\n%rax     00 00 00 00 00 98 96 80\r\n%rcx     00 00 00 00 00 00 00 00\r\n%rdx     00 00 00 00 00 00 00 0a\r\n%rbx     00 00 00 00 00 00 00 01\r\n%rsp     00 00 7f ff 97 44 36 28\r\n%rbp     00 00 00 00 00 00 00 00\r\n%rsi     19 99 99 99 99 99 99 99\r\n%rdi     00 00 00 00 00 00 00 00\r\n%r8      00 00 2a c9 68 1a 50 40\r\n%r9      00 00 7f ff 97 44 46 01\r\n%r10     00 00 00 00 00 98 96 80\r\n%r11     00 00 00 00 00 00 00 0a\r\n%r12     00 00 00 00 00 98 96 80\r\n%r13     00 00 7f ff 97 44 37 20\r\n%r14     00 00 00 00 00 00 00 00\r\n%r15     00 00 00 00 00 00 00 00\r\n\r\n%ymm0    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 00 00\r\n%ymm1    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f 2f\r\n%ymm2    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm3    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 ff\r\n%ymm4    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm5    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm6    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm7    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm8    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm9    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm10   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm11   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm12   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm13   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm14   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n%ymm15   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n\r\n%cf      0 \r\n%1       1 \r\n%pf      1 \r\n%0       0 \r\n%af      0 \r\n%0       0 \r\n%zf      0 \r\n%sf      0 \r\n%tf      0 \r\n%if      1 \r\n%df      0 \r\n%of      0 \r\n%iopl[0] 0 \r\n%iopl[1] 0 \r\n%nt      0 \r\n%0       0 \r\n%rf      0 \r\n%vm      0 \r\n%ac      0 \r\n%vif     0 \r\n%vip     0 \r\n%id      0 \r\n\r\n[ 00007fff 97443630 - 00007fff 97443620 ]\r\n[ 1 valid rows shown ]\r\n\r\n00007fff 97443628   d d d d d d d d   00 00 00 00 00 40 04 6c\r\n\r\n[ 00000000 00000000 - 00000000 00000000 ]\r\n[ 0 valid rows shown ]\r\n\r\n[ 00000000 00000000 - 00000000 00000000 ]\r\n[ 0 valid rows shown ]\r\n\r\n0 more segment(s)\r\n```\r\n\r\nEach entry corresponds to the hardware state that was observed just prior to an\r\nexecution of the `popcnt()` function. The first 60 rows represent the contents\r\nof general purpose, sse, and eflags registers, and the remaining rows represent\r\nthe contents of memory, both on the stack and the heap. Memory is shown eight\r\nbytes at a time, where a block of eight bytes appears only if the target\r\ndereferenced at least one of those bytes. Each row contains values and state\r\nflags. Bytes are flagged as either (v)alid (the target dereferenced this byte),\r\n  or (.)invalid (the target did not dereference this byte). \r\n\r\nEach of the random transformations performed by STOKE are evaluated with\r\nrespect to the contents of this file. Rewrites are compiled into a sandbox and\r\nexecuted beginning from the machine state represented by each entry. Rewrites\r\nare only permitted to dereference defined locations. This includes registers\r\nthat are flagged as `def_in` (see `search.conf`, below), memory locations that\r\nare flagged as 'v', or locations that were written previously. Rewrites are\r\npermitted to write values to all registers and to any memory location that is\r\nflagged as valid. \r\n\r\nSTOKE will produce optimal code that works on the testcases.  The testcases\r\nneed to be selected to help ensure that STOKE doesn't produce an incorrect\r\nrewrite.  In our main.cc file in `examples/tutorial` we choose arguments to the\r\n`popcnt` function to make sure that it sometimes provides arguments that use\r\nmore than 32 bits.  Otherwise, STOKE will sometimes produce a rewrite using the\r\n`popcntl` instruction, which only operates on the bottom half of the register,\r\ninstead of the `popcntq` instruction, which operates on the whole thing.\r\n  Alternatively you can use the formal validator in bounded mode with a large\r\n  bound (over 32).  This large bound is tractable because this example doesn't\r\n  has a small number of cases for memory aliasing (namely, none at all!).  If a\r\n  counterexample is found it can be automatically added to the search so STOKE\r\n  won't make this mistake again.\r\n\r\nThe STOKE sandbox will safely halt the execution of rewrites that perform\r\nundefined behavior. This includes leaving registers in a state that violates\r\nthe x86-64 callee-save ABI, dereferencing invalid memory, performing a\r\ncomputation that results in a floating-point exception, or becoming trapped in\r\na loop that performs more than `max_jumps` (see `search.conf`, below). \r\n\r\nThe final step is to use these testcases and the target code contained in\r\n`bins/_Z6popcntm.s` to run STOKE search by typing:\r\n\r\n    $ stoke search --config search.conf\r\n    \r\nwhere `search.conf` contains:\r\n\r\n```\r\n##### stoke search config file\r\n\r\n--out result.s # Path to write results to\r\n\r\n--target bins/_Z6popcntm.s # Path to the function to optimize\r\n--init empty # Begin search from all nops \r\n\r\n--def_in \"{ %rax %rdi }\" # The registers that are defined on entry to the target\r\n--live_out \"{ %rax }\" # The registers that are live on exit from the target\r\n\r\n--testcases popcnt.tc # Path to testcase file\r\n--training_set \"{ 0 ... 7 }\" # Testcases to use for measuring correctness during search\r\n--test_set \"{ 8 ... 1023 }\"  # Testcases to use as holdout set for checking correctness\r\n\r\n--distance hamming # Metric for measuring error between live-outs\r\n--misalign_penalty 1 # Penalty for results that appear in the wrong location\r\n--reduction sum # Method for summing errors across testcases\r\n--sig_penalty 9999 # Score to assign to rewrites that produce non-zero signals\r\n\r\n--cost \"correctness + latency\" # Measure performance by summing instruction latencies\r\n\r\n--global_swap_mass 0 # Proposal mass\r\n--instruction_mass 1 # Proposal mass\r\n--local_swap_mass 1 # Proposal mass\r\n--opcode_mass 1 # Proposal mass\r\n--operand_mass 1 # Proposal mass\r\n--rotate_mass 0 # Proposal mass\r\n\r\n--beta 1 # Search annealing constant\r\n--initial_instruction_number 5 # The number of nops to start with\r\n\r\n--statistics_interval 100000 # Print statistics every 100k proposals\r\n--timeout_iterations 16000000 # Propose 16m modifications total before giving up\r\n--cycle_timeout 1000000 # Try 1m modifications before restarting\r\n\r\n--strategy hold_out # Verify results using a larger hold out testcase set\r\n```\r\n\r\nSTOKE search will produce two types of status messages. Progress update\r\nmessages will be printed whenever STOKE discovers a new lowest cost verified or\r\nunverified rewrite. The code shown on the left is not equivalent to the target\r\ncode; the code shown on the right is with respect to the current set of\r\ntestcases.\r\n\r\n```\r\nProgress Update: \r\n\r\nLowest Cost Discovered (9)         Lowest Known Correct Cost (15)     \r\n                                                         \r\nbtrq $0xffffffffffffffc0, %rdi     testq %rdi, %rdi      \r\nretq                               je .L_X64ASM_0        \r\n                                   xorl %eax, %eax       \r\n                                   .L_X64ASM_1:          \r\n                                   movl %edi, %edx       \r\n                                   andl $0x1, %edx       \r\n                                   addl %edx, %eax       \r\n                                   shrq $0x1, %rdi       \r\n                                   jne .L_X64ASM_1       \r\n                                   cltq                  \r\n                                   retq                  \r\n                                   .L_X64ASM_0:          \r\n                                   xorl %eax, %eax       \r\n                                   retq\r\n```\r\n\r\nStatistics updates will be printed every `statistics_interval` proposals.\r\nStatistics are shown for the number of proposals that have taken place, elapsed\r\ntime, proposal throughput, and for each of the transformations specified to\r\nhave non-zero mass in `search.conf`.\r\n\r\n```\r\nStatistics Update: \r\n\r\nIterations:   100000\r\nElapsed Time: 0.0836948s\r\nIterations/s: 1.19482e+06\r\n\r\nMove Type       Proposed     Succeeded     Accepted     \r\n                                                        \r\nInstruction     16.791%      5.83%         2.009%       \r\nOpcode          16.646%      8.857%        4.013%       \r\nOperand         16.593%      10.444%       6.864%       \r\nRotate          16.611%      0.791%        0.789%       \r\nLocal Swap      16.597%      1.556%        1.128%       \r\nGlobal Swap     16.762%      7.066%        6.08%     \r\nExtension       0%           0%            0%\r\n\r\nTotal           100%         34.544%       20.883%\r\n```\r\n\r\nWhen search has run to completion, STOKE will write the lowest cost verified\r\nrewrite that it discovered to `result.s`. Because this is a particularly simple\r\nexample, STOKE is almost guaranteed to produce the optimal rewrite:\r\n\r\n```asm\r\n  .text\r\n  .globl _Z6popcntm\r\n  .type _Z6popcntm @function\r\n_Z6popcntm:\r\n  popcnt %rdi, %rax\r\n  retq\r\n  .size _Z6popcntm, .-_Z6popcntm\r\n```\r\n\r\nThis result can then be patched back into the original binary by typing:\r\n\r\n    $ stoke replace --config replace.conf\r\n    \r\nwhere `result.conf` contains:\r\n\r\n```\r\n##### stoke replace config file\r\n\r\n-i ./a.out # Path to the elf binary to patch\r\n--rewrite result.s # Path to the replacement function\r\n```\r\n\r\nAnd runtime can once again be measured by typing:\r\n\r\n    $ time ./a.out 100000000\r\n    \r\n    real  0m0.133s\r\n    user  0m0.109s\r\n    sys   0m0.000s    \r\n\r\nAs expected, the results are close to an order of magnitude faster than the original.\r\n\r\nUsing the Formal Validator\r\n-----\r\n\r\nSTOKE includes a formal validator.  It's design and interface\r\nare detailed in the `src/validator/README.md` file.  To use the formal\r\nvalidator instead of hold out testing, specify `--strategy bounded` for any\r\nSTOKE binary that you use.  For code with loops, all paths will be explored up\r\nto a certain depth, specified using the --bound argument, which defaults to 2.\r\n\r\nAn example of using the validator can be found in the `examples/pairity`\r\nfolder; this example has a Makefile much like the tutorial's and should be easy\r\nto follow.  The key difference is that the pairity example does not use\r\ntestcases to guide search.  Instead, after producing a candidate rewrite,\r\nthe validator checks for equivalence.  If the codes are not equivalent, \r\na counterexample is found, and this is used as a new testcase to help guide search.\r\n\r\nThere are some important limitations to keep in mind while using the validator:\r\n\r\n- Only some instructions are supported.  The `--validator_must_support` flag\r\ncan be used to only propose instructions that can be validated.\r\n- Only the general purpose registers, SSE registers (`ymm0`-`ymm15`) and five of\r\nthe status flags (`CF`, `SF`, `PF`, `ZF`, `OF`) are supported.\r\n- Memory is now fully supported, even in the presence of complex aliasing.\r\n\r\n\r\nAdditional Features\r\n=====\r\n\r\nIn addition to the subcommands described above, STOKE has facilities for\r\ndebugging and benchmarking the performance of each of its core components:\r\n\r\n- `stoke debug cfg`: Generate a pdf of a control flow graph.\r\n- `stoke debug cost`: Compute the cost of a rewrite.\r\n- `stoke debug sandbox`: Step through the execution of a rewrite.\r\n- `stoke debug search`: View the changes produced by performing and undoing a program transformation.\r\n- `stoke debug state`: Check the behavior of operators that manipulate hardware machine states.\r\n- `stoke debug verify`: Check the equivalence of two programs.\r\n- `stoke benchmark cfg`: Measure the time required to recompute a control flow graph.\r\n- `stoke benchmark cost`: Measure the time required to compute a cost function.\r\n- `stoke benchmark sandbox`: Measure the time required to execute a program in a STOKE sandbox.\r\n- `stoke benchmark search`: Measure the time required to perform and undo a transformation to a program.\r\n- `stoke benchmark state`: Measure the time required to reset the memory of a hardware machine state.\r\n- `stoke benchmark verify`: Measure the time required to check the equivalence of two programs.\r\n\r\nShell completion\r\n-----\r\n\r\nSTOKE also comes with support for bash and zsh completion.  To enable either, type:\r\n\r\n  $ make bash_completion\r\n  $ make zsh_completion\r\n\r\nUsing functions to be proposed by STOKE\r\n-----\r\nSTOKE can not only propose instructions when searching for programs, but also propose calls to a list of known functions using the `--functions` command-line argument.  To decide whether these functions read any undefined state (before proposing them), we use a dataflow analysis.  Sometimes, the dataflow analysis can be too imprecise, which is why STOKE allows the user to annotate dataflow information in comments.  Here is an example of a function that clears the overflow flag.  STOKEs dataflow analysis is too imprecise for this code.\r\n\r\n      .text\r\n      .globl clear_of\r\n      .type clear_of, @function\r\n    #! maybe-read { }\r\n    #! maybe-write { %of %r15 }\r\n    #! maybe-undef { }\r\n    .clear_of:\r\n      pushfq\r\n      popq %r15\r\n      andq $0xfffff7ff, %r15\r\n      pushq %r15\r\n      popfq\r\n      retq\r\n\r\n    .size clear_of, .-clear_of\r\n\r\nNote that it is enough to specify the maybe sets, as STOKE will automatically realize that the must sets need to be contained in the maybe set.\r\n\r\nExtending STOKE\r\n=====\r\n\r\nThis repository contains a minimal implementation of STOKE as described in\r\nthe academic papers about STOKE. Most, but not all of the features\r\ndescribed in those papers appear here. Developers who\r\nare interested in refining these features or adding their own extensions are\r\nencouraged to try modifying this implementation as described below.\r\n\r\nCode Organization\r\n-----\r\n\r\nThe STOKE source is organized into modules, each of which correspond to a\r\nsubdirectory of the `src/` directory:\r\n\r\n- `src/analysis`: An aliasing analysis used by the validator.\r\n- `src/cfg`: Control flow graph representation and program analysis.\r\n- `src/cost`: Different cost functions that can be used in the search.\r\n- `src/disassembler`: Runs objdump and parses the results into STOKE's format.\r\n- `src/expr`:  A helper used to parse arithmetic expressions in config files.\r\n- `src/ext`: External dependencies.\r\n- `src/sandbox`: A sandbox for testing proposed code on the hardware.\r\n- `src/search`: An implementation of an MCMC-like algorithm for search.\r\n- `src/state`: Data structures to represent concrete machine states (testcases).\r\n- `src/stategen`: Generates concrete machine states (testcaes) for a piece of code.\r\n- `src/symstate`: Models the symbolic state of the hardware; only used by the formal validator.\r\n- `src/target`: Code to find which instruction sets the CPU supports.\r\n- `src/transform`: Transforms used during search to mutate the code.\r\n- `src/tunit`: Classes for representing a function (x86-64 code along with a name and other metadata).\r\n- `src/verifier`: Wrappers around verification techniques such as testing for formal validation.\r\n- `src/validator`: The formal validator for proving two codes equivalent.\r\n\r\nThe `tools/` directory has the code that performs application logic and reads\r\ncommand line arguments.\r\n\r\n- `tools/apps`: The application logic for stoke binaries\r\n- `tools/args`: Lists of command line arguments used by a gadget (see below).\r\n- `tools/gadgets`: Modules used by applications to configure internal APIs with command line arguments.\r\n- `tools/io`: Code to read/write certain kinds of command line arguments.\r\n- `tools/scripts`: Where we put stuff when we don't have a better place.  Nothing to see here.\r\n- `tools/target`: Arbitrarily named directory with code to read CPU features from cpuinfo.\r\n\r\nGadgets\r\n-----\r\n\r\nThe stoke codebase is setup in a very modular way.  We have components like the\r\n`Sandbox`, which emulates execution of a rewrite on hardware.  Or, we have\r\nsubclasses of `CostFunction` which evaluate the quality of a rewrite.  Or, we\r\nhave an `SMTSolver` which is used by the formal validator to query a backend\r\nlike Z3 or CVC4.  \r\n\r\nOften, several stoke applications will wish to configure one of these modules\r\nin the same way, depending on command line arguments.  Thus, we have \"Gadgets\".\r\nA \"Gadget\" is a subclass of the class you wish to configure which takes care of\r\nextracting all the appropriate command line arguments.  Some Gadgets, like\r\n`SandboxGadget` just define a constructor so that modifies the object's\r\nconfiguration.  More involved ones, like `CostFunctionGadget` actually do work\r\nto create a new `CostFunction` object and define methods that act as a wrapper.\r\n\r\nTherefore, if you want to add a command line option to an existing component of\r\nstoke, you normally are going to want to modify the gadget for that component\r\nin `tools/gadgets` and add the argument in `tools/args`.  Once you do that, it\r\nshould show up uniformly in all of the stoke tools that use that module.\r\n\r\nInitial Search State\r\n-----\r\n\r\nInitial state types are defined in `src/search/init.h` along with an additional\r\ntype for user-defined extensions.\r\n\r\n```c++\r\nenum class Init {\r\n  EMPTY,\r\n  ZERO,\r\n  TARGET,\r\n  PREVIOUS,\r\n\r\n  // Add user-defined extensions here ...\r\n  EXTENSION\r\n};\r\n```\r\n\r\nInitial state is specified using the `--init` command line argument which controls the initial values\r\ngiven to the current, lowest cost, and lowest cost correct search states. This value\r\naffects the behavior of the `Search::configure() const` method, which\r\ndispatches to the family of `Search::configure_xxxxx() const` methods. User-defined\r\nextensions should be placed in the `Search::configure_extension() const` method,\r\nwhich can be triggered by specifying `--init extension`.\r\n\r\n```c++\r\nvoid Search::configure_extension(const Cfg& target, SearchState& state) const {\r\n  // Add user-defined logic here ...\r\n\r\n  // Invariant 1: Search state should agree with target on boundary conditions.\r\n  assert(state.current.def_ins() == target.def_ins());\r\n  assert(state.current.live_outs() == target.live_outs());\r\n\r\n  assert(state.best_yet.def_ins() == target.def_ins());\r\n  assert(state.best_yet.live_outs() == target.live_outs());\r\n\r\n  assert(state.best_correct.def_ins() == target.def_ins());\r\n  assert(state.best_correct.live_outs() == target.live_outs());\r\n\r\n  // Invariant 2: Search state must be in a valid state. This function isn't on\r\n  // a critical path, so this can safely be accomplished by calling\r\n  state.current.recompute();\r\n  state.best_yet.recompute();\r\n  state.best_correct.recompute();\r\n\r\n  // Invariant 3: Search state must agree on first instruction. This instruction\r\n  // must be the label definition that appears in the target.\r\n  assert(state.current.get_code()[0] == target.get_code()[0]);\r\n  assert(state.best_yet.get_code()[0] == target.get_code()[0]);\r\n  assert(state.best_correct.get_code()[0] == target.get_code()[0]);\r\n\r\n  // See Search::configure for additional invariants\r\n}\r\n```\r\n\r\nSearch Transformations\r\n-----\r\n\r\nTransformation types are defined in the `src/transform` directory.  Each\r\ntransform is a subclass of the abstract class `Transform`.  Existing transforms are,\r\n\r\n| Name | Description |\r\n| ---- | ----------- |\r\n| add_nops | Adds one extra nop instruction into the rewrite. |\r\n| delete | Deletes one instruction at random. |\r\n| instruction | Replaces an instruction with another one chosen at random. |\r\n| opcode | Replaces an instruction's opcode with a new one that takes operands of the same type. |\r\n| operand | Replaces an operand of one instruction with another. |\r\n| rotate | Formerly \"resize\".  Moves an instruction from one basic block to another, and shifts all the instructions in between. |\r\n| local_swap | Takes two instructions in the same basic block and swaps them. |\r\n| global_swap |  Takes two instructions in the entire program and swaps them. |\r\n| weighted | Selects from among several other transforms at random. |\r\n\r\n\r\nThese subclasses each implement `operator()(Cfg& cfg)` to mutate a Cfg.  This\r\nfunction returns an object, `TransformInfo` that contains all the information\r\nneeded to undo this transformation, and also whether the transform succeeded\r\n(transforms are allowed to fail).  It's common for this object to be set with\r\nindexes of instructions in the code that were modified, for example.  The\r\nsubclass also implements `undo(Cfg& cfg, TransformInfo ti)`.\r\n\r\nTransforms will often want to select from a collection of operands and opcodes,\r\nand for this purpose they can access the `pools_` protected variable of the\r\nTransform` superclass.  This is of type `TransformPools` and allows access to\r\nthese collections.  This makes it possible to configure the collection of\r\navailable opcodes and operands independently of the transforms.  Also, the\r\n`Transform` superclass has a `gen_` member which is used to produce random\r\nnumbers with a known seed.\r\n\r\nTransformation weights are specified using the family of `--xxxxx_mass` command\r\nline arguments. These values control the distribution of proposals that are\r\nmade by the WeightedTransform, which is the transform used by the\r\nsearch.\r\n\r\nA simple example of how to impelement a transform is in\r\n`src/transform/global_swap.cc`.  Note that all transforms must appropriately\r\nmake a call to recompute any `Cfg` information that needs to be updated and\r\nensure that `cfg.check_invariants()` returns true when done (you can assume it\r\n    returns true at the beginning of the function).\r\n\r\nCost Function\r\n-----\r\n\r\nA cost function is specified using the `--cost` command line argument.  It's an\r\nexpression composed using standard unsigned arithmetic operators.  As\r\nvariables, you can use several measurements of the current rewrite.  The most\r\nimportant of these is `correctness`.  The value `correctness` is (by default)\r\nthe number of bits that differ in the outputs of the target versus the rewrite\r\nsummed across all testcases.  There are some tunable options for this, for\r\nexample, for floating point computations.  In all cases, lower cost is better.\r\n\r\nSome other important cost-variables you can use are:\r\n\r\n| Name | Description |\r\n| ---- | ----------- |\r\n| binsize | The size (in bytes) of the assembled rewrite using the x64asm library. |\r\n| correctness | How \"correct\" the rewrite's output appears.  Very configurable. |\r\n| size | The number of instructions in the assembled rewrite. |\r\n| latency | A poor-man's estimate of the rewrite latency, in clock cycles, based on the per-opcode latency table in `src/cost/tables`. |\r\n| measured | An estimate of running time by counting the number of instructions actually executed on the testcases.  Good for loops and algorithmic improvements.  |\r\n| sseavx |  Returns '1' if both avx and sse instructions are used (this is usually bad!), and '0' otherwise.  Often used with a multiplier like `correctness + 1000*sseavx` |\r\n| nongoal | Returns '1' if the code (after minimization) is found to be equivalent to one in `--non_goal`.  Can also be used with a multiplier. |\r\n\r\nIn typical usage, you will combine the value of `correctness` with other values\r\nyou want to optimize for.  A good starting point is `correctness + measured` or\r\n`correctness + latency` (the latter being default).  Improvements might assign\r\nan SSE-AVX penalty, like `correctness + latency + 10000*sseavx`.\r\n\r\nTo add a new cost function, drop a file into `src/cost` that subclasses\r\n`stoke::CostFunction`.  Look at `src/cost/sseavx.h` for a simple example.  It\r\ncomes down to overloading the `operator()` function to return the value you\r\nwant.  Look at `measured.h` for an example of how to use runtime data from the\r\nsandbox to generate values.  Then, add an entry to the map in\r\n`tools/gadgets/cost_function.h` so that your new function can be found on the\r\ncommand line.\r\n\r\nLive-out Error\r\n-----\r\n\r\nLive-out error measurement types are defined in `src/cost/distance.h` along with an additional type for user-defined extensions.\r\n\r\n```c++\r\nenum class Distance {\r\n  HAMMING,\r\n  ULP,\r\n\r\n  // Add user-defined extensions here ...\r\n  EXTENSION\r\n};\r\n```\r\n\r\nMeasurement type is specified using the `--distance` command line argument.\r\nThis value controls the behavior of the `CorrectnessCost::evaluate_distance()\r\nconst` method, which dispatches to the family of\r\n`CorrectnessCost::xxxxx_distance() const` methods, each of which represent a\r\nmethod computing the distance between 64-bit values. User-defined extensions\r\nshould be placed in the `CostFunction::extension_distance() const` method,\r\nwhich can be triggered by specifying `--distance extension`.\r\n\r\n```c++\r\nCost CostFunction::extension_distance(uint64_t x, uint64_t y) const {                                            \r\n  Cost res = 0;\r\n\r\n  // Add user-defined implementation here ...\r\n\r\n  // Invariant 1: Return value should not exceed max_error_cost\r\n  assert(res <= max_error_cost);\r\n\r\n  return res;                                                                                                   \r\n}\r\n```\r\n\r\nVerification Strategy\r\n-----\r\n\r\nThe verification strategy specifies what kind of verification to do on the\r\nrewrite.  It's controlled using the `--strategy` command line argument.  Right\r\nnow, the options are 'hold_out', 'straight_line' or 'bounded'.\r\n\r\nCommand Line Args\r\n-----\r\n\r\nCommand line arguments can be added to any of the STOKE subcommands using the\r\nfollowing syntax. Argument separators which are printed as part of help\r\nmessages are specified by defining a heading variable:\r\n\r\n```c++\r\nauto& heading = Heading::create(\"Heading Description:\");\r\n```\r\n\r\nCommand line flags are specified by declaring a `FlagArg`.\r\n\r\n```c+++\r\nauto& flag = FlagArg::create(\"flag_name\")\r\n  .alternate(\"alternate_flag_name\")\r\n  .description(\"What this flag does\");\r\n```\r\n\r\nAny of the built-in c++ primitive types are specified by declaring a `ValueArg`.\r\n\r\n```c++\r\nauto& val = ValueArg<int>::create(\"value_name\")\r\n  .alternate(\"alternate_value_name\")\r\n  .usage(\"<int>\")\r\n  .description(\"What this value represents\")\r\n  .default_val(0);\r\n```\r\n\r\nUser-defined types are specified by additionally providing function objects that define I/O methods.\r\n\r\n```c++\r\nstruct T {\r\n  int x, y, z;\r\n};\r\n\r\nstruct Reader {\r\n  void operator()(istream& is, T& t) const {\r\n    is >> t.x >> t.y >> t.z;\r\n  }\r\n};\r\n\r\nstruct Writer {\r\n  void operator()(ostream& os, const T& t) const {\r\n    os << t.x << \" \" << t.y << \" \" << t.z;\r\n  }\r\n};\r\n\r\nauto& val = ValueArg<T, Reader, Writer>::create(\"value_name\")\r\n  .alternate(\"alternate_value_name\")\r\n  .usage(\"<int> <int> <int>\")\r\n  .description(\"What this value represents\")\r\n  .default_val({0,0,0});\r\n```\r\n\r\nFor complex values that are better suited to being read from files, a `FileArg`\r\nmay be more appropriate than a `ValueArg`. The syntax is identical.\r\n\r\n```c++\r\nauto& val = FileArg<Complex, ComplexReader, ComplexWriter>::create(\"value_name\")\r\n  .alternate(\"alternate_value_name\")\r\n  .usage(\"<complex representation>\")\r\n  .description(\"What this value represents\")\r\n  .default_val(Complex());\r\n```\r\n\r\n\r\nContact\r\n=====\r\n\r\nQuestions and comments are encouraged.  Please reach us through the GitHub issue tracker, or alternatively at `stoke-developers@lists.stanford.edu`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}