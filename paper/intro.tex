\section{Introduction}

Equivalence checking is a long-standing yet important problem.
\todo{say more about equivalence checking and why its important, cite
some papers. also mention relational verification}

In both equivalence checking and relational verification, many
state-of-the-art algorithms depend upon a simulation or bisimulation
relation. These relations relate both the data of the two programs
(e.g. by \emph{invariants}) and control flow. However, past works have
generally been very limited in this latter respect; often assumptions
are made that do not hold in practice. For example, as discussed in
Section~\ref{sec:related}, many works assume that each iteration of
a loop in one program corresponds to an iteration of a loop in the
other. In this work we offer a novel algorithm that uses data in
the form of test cases to infer relationships between the control
flow behaviors of the two programs, and use these relationships to
construct and verify a bisimulation relation.

Throughout this paper we use the following terminology. We refer
to the two functions as the \emph{target} and the \emph{rewrite},
although our verification technique is entirely symmetric in
its application. Each of the target and rewrite are composed of
\emph{basic blocks}, and we speak of \emph{paths} that are a sequence
(including possibly an empty sequence) of basic blocks. Our key goal
is to find a \emph{control flow correspondence} between the target and
the rewrite functions. This means that for a given path through the
target program, we can find a corresponding path through the rewrite
that performs the same computation under some condition. Any pair of
execution traces of the two functions starting from the same test
case input can be broken into subtraces, where each subtrace of the
target program corresponds to a subtrace of the rewrite program and
the pair of subtraces illustrate the execution of corresponding paths
\todo{use cutpoint terminology}. A sufficient set of control flow
correspondences can be used to infer and check a bisimulation relation
that implies the correctness of the two programs. Equivalently,
the control flow correspondence can be understood as a program
composition, over which invariants can be learned and equivalence
proved\todo{cite stuff here}.

Our data-driven approach is particularly applicable in domains such as
superoptimization, or where a large test suite already exists for a
program. However, we also demonstrate that test cases may be generated
both through stochastic techniques and via formal methods (for
example, by using models generated by an SMT solver) and practically
used with our algorithm. This work focuses on proving the correctness
of control flow optimizations such as loop unrolling, loop unpeeling
and vectorization for leaf functions written in \arch{} assembly.

Instead of making assumptions that branch conditions between the
target and rewrite match, we instead make an assumption about the way
compilers generate code. In particular, we assume that (i) compilers
will store some kind of index or counter in a register during the
execution of a loop; and (ii) after performing optimizations on the
loop, there will be a linear relationship between the counters of the
two programs at the cutpoints where the states of the two functions
should align. We found that these assumptions always held in practice
for the examples we've considered. However, a limitation is that our
technique at present cannot learn invariants with quantifiers. This
limits our ability to prove the correctness of optimizations that
require richer invariants over the heap state, such as loop fusion
and loop tiling. As a consequence, we assume that the heap states
\todo{and stack?} of the target and rewrite programs are equal at
all cutpoints, which limits the set of verification problems we can
handle. We hope that this question may be addressed in future work.

A key idea is that we can learn a \emph{flow-insensitive invariant},
that is an invariant, a linear equality, which holds at a pair of
program points, \emph{regardless of the path taken through the target
and rewrite to reach the program point}. This is made possible by
introducing \shadow{} that count the number of times each basic block
in the target and rewrite execute. We always find a flow-insensitive
invariant relating the index registers of the two functions, and
usually others as well. From the flow-insensitive invariants, we
can learn the form of a \emph{flow-sensitive invariant} that holds
inductively over successive loop iterations, and from the form of that
invariant we can infer the program composition (or equivalently, the
bisimulation).

Our contributions are:

\begin{itemize}
\item The first fully automatic algorithm for inferring control flow
correspondences between two functions that does not depend upon a
priori assumptions that the branch conditions of one function match
the branch conditions of the other.
\item A new set of benchmarks for evaluating equivalence checking
techniques on optimizations that alter control flow, such as loop
unrolling, loop unpeeling and vectorization.
\end{itemize}

The rest of the paper is structured as follows.
