##### /home/berkeley/stoke/bin/stoke_debug_cost

##### Input programs:

# Registers defined on entry
# --def_in { %rax %rsp ... }
--def_in "{ %rsp }"

# Is heap defined on exit?
# --heap_out 

# Registers live on exit
# --live_out { %rax %rsp ... }
--live_out "{ %rax }"

# Rewrite
--rewrite rewrite.s

# Is stack defined on exit?
# --stack_out 

# Target
--target target.s

##### Input options:

# Shuffle testcase order
# --shuffle_testcases 

# Testcases
--testcases testcase.tc

# Subset of testcase indices to use
# --training_set { 0 1 ... 9 }

##### Optimization options:

# Give up once cost exceeds this value
# --max_cost <int>

##### Correctness options:

# Metric for measuring distance between states
# --distance (hamming|ulp)

# Minimum ULP value to record
# --min_ulp <int>

# Penalty for correct values in incorrect locations
# --misalign_penalty <int>

# Reduction method
# --reduction (max|sum)

# Allow correct values in incorrect memory locations
# --relax_mem 

# Allow correct values in incorrect register locations
--relax_reg 

# Penalty for incorrect signal behavior
# --sig_penalty <int>

# Number of values in sse registers
# --sse_count <int>

# Number of bytes in sse elements
# --sse_width (1|2|4|8)

##### Performance options:

# Latency multiplier for nested code
# --nesting_penalty <int>

# Performance definition
--perf none

##### Sandbox options:

# Maximum jumps before exit due to infinite loop
# --max_jumps <int>

##### Help and argument utilities:

# Read program args from a configuration file
# --config <path/to/file.dat>

# Print program arguments and quit
# --debug_args 

# Print an example configuration file
# --example_config <path/to/file.dat>

# Print this message and quit
# --help 

